*** declare one-dimensional sets -----------------------------------------------

sets
*** building state dimensions
bsr     "renovated building shell"
hsr     "renovated heating system"
bs(bsr) "building shell"
hs(hsr) "heating system"

*** vintages
vin "construction vintage cohort"

*** energy carriers
carrier "energy carrier"

*** buildings subsectors
sec "buildings subsector"

*** stock subset dimesions
region "all regions"
reg(region) "regions"
loc "location of building (rural, urban)"
typ "type of building (SFH, MFH, Com)"
inc "income quantile"

*** temporal sets
tall        "all time steps"
ttot(tall)  "all modelling time steps"
t(ttot)     "modelled time steps"
thist(ttot) "historic time steps"
tinit(ttot) "initial modelling time step"

*** model fundamentals
cost "type of cost"
  /
  tangible   "tangible cost (exogenous)"
  intangible "intangible cost (identified in calibration)"
  /
var "mayor variables of the model"
  / stock, construction, renovation, demolition /
varFlow(var) "flow variables of the model"
  / construction, renovation, demolition /

*** model analytics
solveinfo	"model and solver stats"
  /
  solvestat "solver termination condition"
  modelstat "model status"
  resusd    "time the solver used to solve the model in seconds"
  objval    "objective function value"
  /

*** matching reference sources
qty    "quantity unit to measure stocks and flows in"
  /
  area "floor area in million m2 or million m2/yr"
  num  "number of dwellings (residential) or buildings (commercial) in million or million/yr"
  /
q(qty) "quantity unit used to measure stocks and flows in"

reference             "reference sources that historic quantities can be calibrated to"
refAbs(reference)     "absolute reference sources that historic quantities can be calibrated to"
refRel(reference)     "relative reference sources that historic quantities can be calibrated to"
ref(reference)        "reference sources that historic quantities are calibrated to"
refVar                "variables of reference sources"
refVarGroup           "group of reference variables"

!! AUTOCODE.declareRefMaps
!! Don't edit by hand, code is generated by R script
!! AUTOCODE_end.declareRefMaps

*** for calibration: renovation types (identical replacement, new system, 0)
renType "Renovation types"
  / identRepl, newSys, 0 /
;

*** aliases
alias(bsr,bsr2,bsr3,bsr4,bsr5);
alias(hsr,hsr2,hsr3,hsr4,hsr5);
alias(bs,bs2,bs3);
alias(hs,hs2,hs3);
alias(vin,vin2,vin3);
alias(ttot,ttot2,ttotIn,ttotOut);
alias(t,t2);


*** initialise one-dimensional sets --------------------------------------------

*** load fundamental sets
$gdxin input.gdx
$load bsr hsr bs hs
$load region loc typ inc
$load tall ttot t thist tinit
$load vin
$load carrier
$load sec
$gdxin

*** load reference sets
$ifthen.matching "%RUNTYPE%" == "matching"
$gdxin references.gdx
$load reference refAbs refRel refVar ref refVarGroup
!! AUTOCODE.loadRefMaps
!! Don't edit by hand, code is generated by R script
!! AUTOCODE_end.loadRefMaps
$gdxin
$endif.matching

*** declare multi-dimensional sets ---------------------------------------------

sets
*** building subset
all_subs(region,loc,typ,inc) "all building stock subsets"
subs(region,loc,typ,inc)     "building stock subsets in the solution process"


*** building state
stateFull(bsr,hsr)      "building state incl 0 for no renovation"
state(bs,hs)            "building state"
ren(bs,hs,bsr,hsr)      "renovation alternatives"

*** mappings to filter unwanted combinations
vinExists(ttot,vin)                                  "existing vintage cohorts (i.e. ttot cannot be before cohort starts)"
renAllowed(bs,hs,bsr,hsr)                            "allowed renovation transitions"
renAllowedBS(bs,hs,bsr)                              "allowed building shell retrofits"
renAllowedHS(bs,hs,hsr)                              "allowed heating system replacements"
sameState(bs,hs,bsr,hsr)                             "Is the state after the renovation the same as before"
renEffective(bs,hs,bsr,hsr)                          "Renovations without untouched buildings"
refVarExists(reference,refVar,region,ttot)           "There is a value for this combination of reference, variable, region and period"
refVarGroupExists(reference,refVarGroup,region,ttot) "There is a value for this combination of reference, variable group, region and period"
refVarRef(reference,refVar)                          "mapping references to reference variables"
refVarConsidered(reference,refVar)                   "mapping references to all reference variables that are considered in the deviation"
refVarBasic(reference,refVar,refVarGroup)            "mapping reference variables to group summed to basic value of a share reference"
hsCarrier(hs,carrier)                                "mapping between heating system and energy carrier"
typInSec(typ,sec)                                    "mapping between building type and buildings subsector"

*** control sets (should be empty)
ErrStock(bs,hs,vin,region,loc,typ,inc,ttot)              "Error in stock of buildings"
ErrConstruction(bs,hs,region,loc,typ,inc,ttot)           "Error in flow of new buildings"
ErrRenovation(bs,hs,bsr,hsr,vin,region,loc,typ,inc,ttot) "Error in flow of renovated and untouched buildings"
ErrDemolition(bs,hs,vin,region,loc,typ,inc,ttot)         "Error in flow of demolished buildings"


*** heating system ban
hsBan(var,region,ttot,hs) "heating systems are forbidden in the respective variable after given period"
;

*** aliases
alias(state,state2,state3,state4);
alias(stateFull,stateFull2,stateFull3,stateFull4);
alias(renAllowed,renAllowed2);


*** initialise multi-dimensional sets ------------------------------------------

*** load fundamental sets
$gdxin input.gdx
$load renAllowedBS renAllowedHS renAllowed
$load vinExists
$load hsCarrier
$load typInSec
$load hsBan
$gdxin

$ifthen.matching "%RUNTYPE%" == "matching"
$gdxin references.gdx
$load refVarRef refVarConsidered
$load refVarExists refVarGroupExists
$load refVarBasic
$gdxin
$endif.matching

reg(region)                  = yes;
all_subs(region,loc,typ,inc) = yes;
subs(all_subs)               = yes;
stateFull(bsr,hsr)           = yes;
state(bs,hs)                 = yes;
ren(state,stateFull)         = yes;
renAllowed(state,bsr,hsr)$(    renAllowedBS(state,bsr)
                           and renAllowedHS(state,hsr)) = yes;

*** TODO: initialise mappings with loaded data
sameState(bs,hs,bsr,hsr)$(    (sameas(bsr,bs) or sameas(bsr,"0"))
                          and (sameas(hsr,hs) or sameas(hsr,"0"))) = yes;
renEffective(bs,hs,bsr,hsr)$(not(sameas(bsr,"0") and sameas(hsr,"0"))) = yes;


*** temporal fixes, to be checked ---------------------------------------------



$ifthen.calibrationOptimization "%CALIBRATIONMETHOD%" == "optimization"

sets
tcalib(ttot) "time steps considered by the calibration when minimising deviation from target trajectories"
*** Temporary: Store renovation combinations with at least one zero element
$ifThen.sequentialRen  "%SEQUENTIALREN%" == "TRUE"
zeroFlowBS(bs, hs, bsr)      "renovation combinations where the building shell is left untouched"
zeroFlowHS(bs, hs, hsr)      "renovation combinations where the heating system is left untouched"
$else.sequentialRen
zeroFlow(bs,hs,bsr,hsr)      "renovation combinations where the building shell or the heating system are left untouched"
$endIf.sequentialRen
;

alias(tcalib, tcalib2);

$gdxin input.gdx
$load tcalib
$gdxin

***Determine sets of flows which are included in the stock calibration
$ifThen.sequentialRen "%SEQUENTIALREN%" == "TRUE"
$ifthen.shell not "%ignoreShell%" == "TRUE"
zeroFlowBS(bs,hs,bsr)$(renAllowedBS(bs,hs,bsr) and sameas(bsr,"0")) = YES;
$else.shell
zeroFlowBS(bs,hs,bsr) = NO;
$endIf.shell
zeroFlowHS(bs,hs,hsr)$(renAllowedHS(bs,hs,hsr) and sameas(hsr,"0")) = YES;

$else.sequentialRen
$ifthen.shell "%ignoreShell%" == "TRUE"
zeroFlow(bs,hs,bsr,hsr)$(renAllowed(bs,hs, bsr, hsr) and sameas(hsr,"0")) = YES;
$else.shell
zeroFlow(bs,hs,bsr,hsr)$(renAllowed(bs,hs, bsr, hsr) and (sameas(bsr, "0") or sameas(hsr,"0"))) = YES;
$endIf.shell
$endIf.sequentialRen

$ifthen.calibrationRun "%RUNTYPE%" == "calibration"

sets
vinCalib(ttot, vin)  "Dynamic vintages in calibration"
gradientVarsCon(bs, hs, ttot)                       "Construction combinations to loop over to compute the gradient in the calibration"
$ifThen.sequentialRen "%SEQUENTIALREN%" == "TRUE"
gradientVarsRenBS(bsr, vin, ttot)                                "BS renovation combinations to loop over to compute the gradient in the calibration"
gradientVarsRenHS(renType, hsr, vin, ttot)                       "HS renovation combinations to loop over to compute the gradient in the calibration"
$else.sequentialRen
gradientVarsRen(renType, bsr, hsr, vin, ttot)                    "Renovation combinations to loop over to compute the gradient in the calibration"
$endIf.sequentialRen
;

alias(renType, renType2);
alias(vinCalib, vinCalib2);

$gdxin input.gdx
$load vinCalib
$gdxin

*** Determine the combinations to loop over in the calibration
$ifThen.sequentialRen "%SEQUENTIALREN%" == "TRUE"
loop(renAllowedBS(bs, hs, bsr),
  gradientVarsRenBS(bsr, vin, tcalib)$vinCalib(tcalib, vin) = YES;
);
loop((renAllowedHS(bs, hs, hsr), vinCalib(tcalib, vin)),
  gradientVarsRenHS("identRepl", hsr, vin, tcalib)$sameas(hs, hsr) = YES;
  gradientVarsRenHS("newSys", hsr, vin, tcalib)$(not sameas(hs, hsr) and not sameas(hsr, "0")) = YES;
  gradientVarsRenHS("0", hsr, vin, tcalib)$(sameas(hsr, "0")) = YES;
);
$else.sequentialRen
loop((renAllowed(bs, hs, bsr, hsr), vinCalib(tcalib, vin)),
  gradientVarsRen("identRepl", bsr, hsr, vin, tcalib)$sameas(hs, hsr) = YES;
  gradientVarsRen("newSys", bsr, hsr, vin, tcalib)$(not sameas(hs, hsr) and not sameas(hsr, "0")) = YES;
  gradientVarsRen("0", bsr, hsr, vin, tcalib)$(sameas(hsr, "0")) = YES;
);
$endIf.sequentialRen
gradientVarsCon(bs, hs, tcalib) = YES;

$endif.calibrationRun

$endif.calibrationOptimization
